import type { BlueprintEdge, BlueprintNode, PinDefinition } from "../types";
import { PinType } from "../types";
import { getNodeTemplate } from "../ue/nodeCatalog";

interface PinLinkRef {
  nodeName: string;
  pinId: string;
}

interface SerializedPin {
  id: string;
  handleId: string;
  name: string;
  direction: "EGPD_Input" | "EGPD_Output";
  type: PinType;
  defaultValue?: string;
  value?: string;
  links: PinLinkRef[];
}

interface SerializableNode {
  id: string;
  name: string;
  classPath: string;
  posX: number;
  posY: number;
  guid: string;
  comment?: string;
  pure?: boolean;
  pins: SerializedPin[];
}

const DEFAULT_CLASS_PATH = "/Script/BlueprintGraph.K2Node_CallFunction";

const PIN_TYPE_META: Record<PinType, { category: string; subCategory?: string; subCategoryObject?: string }> = {
  [PinType.Exec]: { category: "exec" },
  [PinType.Boolean]: { category: "bool" },
  [PinType.Integer]: { category: "int" },
  [PinType.Float]: { category: "real", subCategory: "float" },
  [PinType.String]: { category: "string" },
  [PinType.Vector]: {
    category: "struct",
    subCategoryObject: `/Script/CoreUObject.ScriptStruct'"/Script/CoreUObject.Vector"'`,
  },
  [PinType.Rotator]: {
    category: "struct",
    subCategoryObject: `/Script/CoreUObject.ScriptStruct'"/Script/CoreUObject.Rotator"'`,
  },
  [PinType.Object]: { category: "object" },
  [PinType.Class]: { category: "class" },
  [PinType.Struct]: { category: "struct" },
  [PinType.Byte]: { category: "byte" },
  [PinType.Name]: { category: "name" },
  [PinType.Text]: { category: "text" },
  [PinType.Delegate]: { category: "delegate" },
};

const DEFAULT_PIN_TYPE_META = { category: "struct" };

const boolLiteral = (value: boolean) => (value ? "True" : "False");

const sanitizeName = (value: string) => {
  const cleaned = value.replace(/[^A-Za-z0-9_]/g, "");
  return cleaned.length ? cleaned : "Node";
};

const escapeValue = (value: string) =>
  value
    .replace(/\\/g, "\\\\")
    .replace(/"/g, '\"')
    .replace(/\n/g, "\\n");

const randomGuid = () => {
  if (typeof globalThis.crypto?.randomUUID === "function") {
    return globalThis.crypto.randomUUID().replace(/-/g, "").toUpperCase();
  }
  return Array.from({ length: 4 })
    .map(() => Math.floor(Math.random() * 0xffffffff).toString(16).padStart(8, "0"))
    .join("")
    .toUpperCase();
};

const defaultValueForType = (pin: SerializedPin) => {
  if (pin.value && pin.value.length > 0) {
    return pin.value;
  }
  if (pin.defaultValue && pin.defaultValue.length > 0) {
    return pin.defaultValue;
  }

  switch (pin.type) {
    case PinType.Boolean:
      return "false";
    case PinType.Integer:
    case PinType.Byte:
      return "0";
    case PinType.Float:
      return "0.0";
    case PinType.String:
    case PinType.Name:
    case PinType.Text:
      return "";
    default:
      return "";
  }
};

const pinTypeFragment = (pin: SerializedPin) => {
  const meta = PIN_TYPE_META[pin.type] ?? DEFAULT_PIN_TYPE_META;
  return [
    `PinType.PinCategory="${meta.category}"`,
    `PinType.PinSubCategory="${meta.subCategory ?? ""}"`,
    `PinType.PinSubCategoryObject=${meta.subCategoryObject ?? "None"}`,
    "PinType.PinSubCategoryMemberReference=()",
    "PinType.PinValueType=()",
    "PinType.ContainerType=None",
    `PinType.bIsReference=${boolLiteral(false)}`,
    `PinType.bIsConst=${boolLiteral(false)}`,
    `PinType.bIsWeakPointer=${boolLiteral(false)}`,
    `PinType.bIsUObjectWrapper=${boolLiteral(false)}`,
    `PinType.bSerializeAsSinglePrecisionFloat=${boolLiteral(false)}`,
  ];
};

const serializePin = (pin: SerializedPin) => {
  const parts = [
    `PinId=${pin.id}`,
    `PinName="${escapeValue(pin.name || "Value")}"`,
    `Direction="${pin.direction}"`,
    ...pinTypeFragment(pin),
  ];

  const defaultValue = defaultValueForType(pin);
  parts.push(`DefaultValue="${escapeValue(defaultValue)}"`);
  parts.push(`AutogeneratedDefaultValue="${escapeValue(defaultValue)}"`);
  parts.push("PersistentGuid=00000000000000000000000000000000");
  parts.push(`bHidden=${boolLiteral(false)}`);
  parts.push(`bNotConnectable=${boolLiteral(false)}`);
  parts.push(`bDefaultValueIsReadOnly=${boolLiteral(false)}`);
  parts.push(`bDefaultValueIsIgnored=${boolLiteral(false)}`);
  parts.push(`bAdvancedView=${boolLiteral(false)}`);
  parts.push(`bOrphanedPin=${boolLiteral(false)}`);

  if (pin.links.length > 0) {
    const refs = pin.links.map((link) => `${link.nodeName} ${link.pinId}`).join(",");
    parts.push(`LinkedTo=(${refs},)`);
  }

  return `CustomProperties Pin (${parts.join(",")},)`;
};

const classFromTemplate = (node: BlueprintNode): string => {
  const key = node.data.templateKey;
  if (key) {
    try {
      const template = getNodeTemplate(key);
      const match = template.description.match(/\(([^)]+)\)/);
      if (match?.[1]) {
        return match[1];
      }
    } catch {
      // ignore
    }
  }

  if (typeof node.data.description === "string") {
    const match = node.data.description.match(/\(([^)]+)\)/);
    if (match?.[1]) {
      return match[1];
    }
  }

  return DEFAULT_CLASS_PATH;
};

const makePinId = () => randomGuid();

const pushPins = (
  pins: SerializedPin[],
  pinDefs: PinDefinition[] = [],
  direction: "EGPD_Input" | "EGPD_Output"
) => {
  pinDefs.forEach((pin, index) =>
    pins.push({
      id: makePinId(),
      handleId: pin.id || `${direction}-${index}`,
      name: pin.name,
      type: pin.type ?? PinType.Struct,
      defaultValue: pin.defaultValue,
      value: pin.value,
      direction,
      links: [],
    })
  );
};

const makeNode = (node: BlueprintNode, index: number): SerializableNode => {
  const nodeNameBase = sanitizeName(node.data.templateKey || node.data.label || "Node");
  const nodeName = `${nodeNameBase}_${index}`;

  const pins: SerializedPin[] = [];
  pushPins(pins, node.data.inputs, "EGPD_Input");
  pushPins(pins, node.data.outputs, "EGPD_Output");

  return {
    id: node.id,
    name: nodeName,
    classPath: classFromTemplate(node),
    posX: Math.round(node.position?.x ?? 0),
    posY: Math.round(node.position?.y ?? 0),
    guid: randomGuid(),
    comment: node.data.comment,
    pure: !!node.data.pure,
    pins,
  };
};

const pinLookupKey = (nodeId: string, pinId: string) => `${nodeId}:${pinId}`;

export const buildUeClipboard = (nodes: BlueprintNode[], edges: BlueprintEdge[]): string => {
  if (!nodes || nodes.length === 0) {
    return "";
  }

  const serializableNodes = nodes.map((node, index) => makeNode(node, index));

  const pinLookup = new Map<string, { node: SerializableNode; pin: SerializedPin }>();
  serializableNodes.forEach((node) => {
    node.pins.forEach((pin) => {
      pinLookup.set(pinLookupKey(node.id, pin.handleId), { node, pin });
    });
  });

  edges.forEach((edge) => {
    if (!edge.source || !edge.target || !edge.sourceHandle || !edge.targetHandle) {
      return;
    }
    const sourcePin = pinLookup.get(pinLookupKey(edge.source, edge.sourceHandle));
    const targetPin = pinLookup.get(pinLookupKey(edge.target, edge.targetHandle));
    if (!sourcePin || !targetPin) {
      return;
    }

    sourcePin.pin.links.push({ nodeName: targetPin.node.name, pinId: targetPin.pin.id });
    targetPin.pin.links.push({ nodeName: sourcePin.node.name, pinId: sourcePin.pin.id });
  });

  const lines: string[] = [];
  serializableNodes.forEach((node) => {
    lines.push(`Begin Object Class="${node.classPath}" Name="${node.name}"`);
    lines.push(`   NodePosX=${node.posX}`);
    lines.push(`   NodePosY=${node.posY}`);
    lines.push(`   NodeGuid=${node.guid}`);
    if (node.comment) {
      lines.push(`   NodeComment="${escapeValue(node.comment)}"`);
    }
    if (node.pure) {
      lines.push(`   bIsPureFunc=${boolLiteral(true)}`);
    }
    node.pins.forEach((pin) => {
      lines.push(`   ${serializePin(pin)}`);
    });
    lines.push("End Object");
    lines.push("");
  });

  return lines.join("\n").trim();
};
