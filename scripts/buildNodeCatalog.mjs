import fs from "fs";
import path from "path";

const repoRoot = "/Users/mandl/Desktop/projects/blueprint-gpt";
const testsDir = path.join(repoRoot, "tmp_ueblueprint", "tests");

if (!fs.existsSync(testsDir)) {
  console.error("Tests directory not found; clone barsdeveloper/ueblueprint first.");
  process.exit(1);
}

const walk = (dir) => {
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  let files = [];
  for (const entry of entries) {
    const full = path.join(dir, entry.name);
    if (entry.isDirectory()) files = files.concat(walk(full));
    else if (entry.isFile() && entry.name.endsWith(".spec.js")) files.push(full);
  }
  return files;
};

const files = walk(testsDir);

const pinCategoryMap = {
  exec: "Exec",
  wildcard: "Struct",
  bool: "Boolean",
  boolean: "Boolean",
  byte: "Byte",
  class: "Class",
  name: "Name",
  text: "Text",
  string: "String",
  int: "Integer",
  int16: "Integer",
  int32: "Integer",
  int64: "Integer",
  integer: "Integer",
  float: "Float",
  double: "Float",
  real: "Float",
  rotator: "Rotator",
  vector: "Vector",
  vector2d: "Vector",
  vector3f: "Vector",
  vector4f: "Vector",
  struct: "Struct",
  object: "Object",
  interface: "Object",
  softobject: "Object",
  softclass: "Class",
  delegate: "Delegate",
};

const pinCategoryMapInverse = Object.fromEntries(
  Object.values(pinCategoryMap).map((value) => [value, value])
);

const nodeTypeStrings = {
  function: "Function",
  event: "Event",
  input_event: "InputEvent",
  variable_get: "VariableGet",
  variable_set: "VariableSet",
  flow_control: "FlowControl",
};

const nodeTypeGuards = [
  { rule: /K2Node_Input.*Event/, type: "input_event" },
  { rule: /K2Node_Event/, type: "event" },
  { rule: /K2Node_VariableGet/, type: "variable_get" },
  { rule: /K2Node_VariableSet/, type: "variable_set" },
  { rule: /IfThenElse|ExecutionSequence|DoN|DoOnce|FlipFlop|ForLoop|WhileLoop|Switch|Branch/i, type: "flow_control" },
];

const toNodeType = (classPath) => {
  for (const guard of nodeTypeGuards) {
    if (guard.rule.test(classPath)) return guard.type;
  }
  return "function";
};

const normalizeKey = (label) => {
  const stripped = label.replace(/[^A-Za-z0-9]/g, "");
  return stripped.length ? stripped : label.replace(/\s+/g, "");
};

const parseAttr = (text, attr) => {
  const regex = new RegExp(`${attr}=([^,\n)]+)`);
  const match = text.match(regex);
  if (!match) return undefined;
  let value = match[1].trim();
  if (value.startsWith('"') && value.endsWith('"')) {
    value = value.slice(1, -1);
  }
  return value;
};

const resolvePinName = (body) => {
  const friendly = parseAttr(body, "PinFriendlyName");
  if (friendly) {
    const localized = friendly.match(/"([^"]+)"\s*\)/);
    if (localized) return localized[1];
  }
  return parseAttr(body, "PinName") || "Pin";
};

const extractPinBodies = (block) => {
  const bodies = [];
  const marker = "CustomProperties Pin (";
  let index = block.indexOf(marker);
  while (index !== -1) {
    let depth = 1;
    let cursor = index + marker.length;
    let body = "";
    while (cursor < block.length && depth > 0) {
      const char = block[cursor];
      if (char === "(") depth++;
      if (char === ")") depth--;
      if (depth > 0) body += char;
      cursor++;
    }
    bodies.push(body);
    index = block.indexOf(marker, cursor);
  }
  return bodies;
};

const extractPins = (block) => {
  const pins = [];
  for (const body of extractPinBodies(block)) {
    const pinName = resolvePinName(body);
    const direction = parseAttr(body, "Direction") === "EGPD_Output" ? "output" : "input";
    const category = parseAttr(body, "PinType.PinCategory")?.toLowerCase();
    let pinType = pinCategoryMap[category || ""];
    if (!pinType) {
      const subObj = parseAttr(body, "PinType.PinSubCategoryObject");
      if (subObj) {
        const norm = subObj.toLowerCase();
        if (norm.includes("vector")) pinType = "Vector";
        else if (norm.includes("rotator")) pinType = "Rotator";
        else if (norm.includes("linearcolor")) pinType = "Struct";
        else if (norm.includes("text")) pinType = "Text";
      }
    }
    if (!pinType) pinType = "Struct";
    const defaultValue = parseAttr(body, "DefaultValue") || parseAttr(body, "AutogeneratedDefaultValue");
    pins.push({ name: pinName, direction, type: pinType, defaultValue });
  }
  return pins;
};

const catalog = {};

for (const file of files) {
  const content = fs.readFileSync(file, "utf8");
  const nameMatch = content.match(/name:\s*"([^"]+)"/);
  if (!nameMatch) continue;
  const label = nameMatch[1];
  const titleMatch = content.match(/title:\s*"([^"]+)"/);
  const title = titleMatch ? titleMatch[1] : label;
  const rawMatch = content.match(/value:\s*String\.raw`([\s\S]*?)`/);
  if (!rawMatch) continue;
  const blueprint = rawMatch[1];
  const blockMatch = blueprint.match(/Begin Object[\s\S]*?End Object/);
  if (!blockMatch) continue;
  const block = blockMatch[0];
  const classMatch = block.match(/Class=([^\s]+)/);
  if (!classMatch) continue;
  const classPath = classMatch[1];
  if (!/K2Node/i.test(classPath)) continue;
  const pins = extractPins(block);
  if (!pins.length) continue;
  const keyBase = normalizeKey(title);
  let key = keyBase;
  let index = 2;
  while (catalog[key]) {
    key = `${keyBase}${index++}`;
  }
  catalog[key] = {
    key,
    label: title,
    nodeType: toNodeType(classPath),
    description: `${title} (${classPath})`,
    pins,
  };
}

const sortedEntries = Object.entries(catalog).sort((a, b) => a[0].localeCompare(b[0]));

const tsLines = [];
tsLines.push("import { NodeType, PinType } from \"../types\";");
tsLines.push("");
tsLines.push("export const GENERATED_NODE_LIBRARY = {");

for (const [, data] of sortedEntries) {
  tsLines.push(`  \"${data.key}\": {`);
  tsLines.push(`    key: \"${data.key}\",`);
  tsLines.push(`    label: \"${data.label.replace(/\"/g, '\\"')}\",`);
  tsLines.push(`    nodeType: NodeType.${nodeTypeStrings[data.nodeType]},`);
  tsLines.push(`    description: \"${data.description.replace(/\"/g, '\\"')}\",`);
  tsLines.push("    pins: [");
  for (const pin of data.pins) {
    tsLines.push("      {");
    tsLines.push(`        name: \"${pin.name.replace(/\"/g, '\\"')}\",`);
    tsLines.push(`        type: PinType.${pin.type},`);
    tsLines.push(`        direction: \"${pin.direction}\",`);
    if (pin.defaultValue) {
      tsLines.push(`        defaultValue: \"${pin.defaultValue.replace(/\\/g, "\\\\").replace(/\"/g, '\\"')}\",`);
    }
    tsLines.push("      },");
  }
  tsLines.push("    ],");
  tsLines.push("  },");
}

tsLines.push("} as const;");
tsLines.push("");
tsLines.push("export type GeneratedNodeLibrary = typeof GENERATED_NODE_LIBRARY;");
tsLines.push("export default GENERATED_NODE_LIBRARY;");

const outPathTs = path.join(repoRoot, "blueprint-vibe", "ue", "nodeCatalog.generated.ts");
fs.writeFileSync(outPathTs, tsLines.join("\n"));
console.log(`Exported ${sortedEntries.length} nodes to ${outPathTs}`);
